​                **泛型与集合**

**[** **实验目的 ]**

**1****）掌握泛型的定义和使用。**

**2****）掌握常用集合泛型类的使用。**

**[** **实验内容 ]**

**涉及知识点：------------------------------------------**

**一、** **泛型**

   **Java****泛型的主要目的是可以建立具有类型安全的数据结构，如链表、散列表等数据结构，最重要的一个优点就是：在使用这些泛型类建立的数据结构时，不必进行强制类型转换，即不要求进行运行时类型检查。SDK1.5****是支持泛型的编译器，它将运行时类型检查提前到编译时执行，使代码更安全。**

**(1)****泛型类声明**

   **可以使用“class** **名称<****泛型列表>****”声明一个类，为了和普通的类有所区别，这样声明的类称作泛型类，如：**

​     **class A<E >**

   **其中A****是泛型类的名称，E****是其中的泛型，也就是说我们并没有指定E****是何种类型的数据，它可以是任何对象或接口，但不能是基本类型数据。**

 **(2)****泛型类的类体和和普通类的类体完全类似，由成员变量和方法构成，如：**

  **class Chorus<E,F>**

  **{**

   **void makeChorus(E person,F yueqi)**

​    **{**

​    **person.toString();  yueqi.toString();**

​    **}**

**}**

**(3)** **使用泛型类声明对象时，必须要指定类中使用的泛型的具体实际类型。例如：**

 **Chorus<****歌手,****乐器> model= new Chorus<****歌手,****乐器> ();**

 

**例子：**

**class Chorus<E,F>{**

  **void makeChorus(E person,F yueqi){**

​    **person.toString();**

​    **yueqi.toString();**

  **}**

**}**

**class** **歌手{**

  **public String toString(){**

​    **System.out.println("****好一朵美丽的茉莉花");**

​    **return "";**

  **}**

**}**

**class** **乐器{**

  **public String toString(){**

​    **System.out.println("|3 35 6116|5 56 5-|");**

​    **return "";**

  **}**

**}**

**public class Example5_20{**

  **public static void main(String args[]){**

​    **Chorus<****歌手,****乐器> model=new Chorus<****歌手,****乐器>();  //****创建一个对象model**

​    **歌手 pengliyuan=new** **歌手();**

​    **乐器 piano=new** **乐器();**

​    **model.makeChorus(pengliyuan,piano);**

  **}**

**}**

   **Java****中的泛型类和C++****的类模板有很大的不同，在上述例子中，泛型类中的泛型数据person****和yueqi****只能调用Object****类中的方法，因此“歌手类”和“乐器类”都重写了Object****类的toString****（）方法。**

 

**(4)Object****类中的常用方法：toString(), equals(),clone(), getclass(), hashcode(), notify(), notify()All(), wait()****等**

 

 

**二、** **ArrayList<E>****泛型**

**ArrayList****代表长度可变的数组，允许对元素进行随机的快速访问，但是向ArrayList****中插入与删除元素的速度较慢。ArrayList****是线程不安全的。**

**(1)****创建一个字符串ArrayList****：**

**ArrayList****<String>  list=new ArrayList <String>();**

 

**(2)ArrayList****的常用方法：**

**①**   **通过add()****方法添加对象。**

**②**   **contains()****方法可以返回ArrayList****中是否含有的对象的真值**

**③**   **使用remove()****方法移除ArrayList****中的对象。**

**④**   **用get()****方法得到对象。**

**④** **用subList()****方法得到从fromIndex(****包括)****和 toIndex(****不包括)****之间的部分视图。**

**⑤ Collections.sort(sub)****语句对容器中的对象按字母进行排序。**

**⑤**   **Collections.shuffle(sub,rand)****语句使用指定的随机源对指定列表进行置换。**

**⑥**   **retainAll()****方法是一种有效的“交集”操作，在本例中，它保留了所有同时在两个ArrayList****对象中的元素。**

**⑨** **执行list.toArray()****语句返回一个数组，该数组包含容器中的所有元素。**

**⑩** **执行list.toArray(new String[0]** **语句返回一个数组，该数组包含容器中的所有元素，返回数组的运行时类型与参数数组的类型完全相同，而不是单纯的Object****。**

 

**三、** **LinkedList<E>****泛型**

**LinkedList<E>****类可以创建链表结构的数据对象。LinkedList****在内部是采用双向循环链表实现的，插入与删除元素的速度较快，随机访问速度则较慢。链表是由若干个节点组成的一种数据结构，每个节点含有一个数据和下一个节点的引用（单链表），或含有一个数据并含有上一个节点的引用和下一个节点的引用（双链表），节点的索引从0****开始。链表适合动态地改变它存储的数据，如，增加、删除节点等。** 

**(1)****创建一个字符串LinkedList****：**

**LinkedList<String>  list=new LinkedList<String>();**

 

**(2)LinkedList<E>****泛型类的一些常用方法。**

  **public boolean add(E element)** **向链表末尾添加一个新的节点，该节点中的数据是参数elememt****指定的对象。**

  **public void add(int index ,E element)** **向链表的指定位置添加一个新的节点，该节点中的数据是参数elememt****指定的对象。**

  **public void addFirst(E element)** **向链表的头添加新节点，该节点中的数据是参数elememt****指定的对象。**

**public E removeFirst()** **删除第一个节点，并返回这个节点中的对象。**

  **public E removeLast()** **删除最后一个节点对象，并返回这个节点中的对象。**

  **public E get(int index)** **得到链表中指定位置处节点中的对象。**

  **public E getFirst()** **得到链表中第一个节点中的对象。**

  **public E getLast()** **得到链表中最后一个节点中的对象。**

  **public int indexOf(E element)** **返回含有数据element****的节点在链表中首次出现的位置，如果链表中无此节点则返回-1****。**

**public int lastIndexOf(E element)** **返回含有数据element****的节点在链表中最后出现的位置，如果链表中无此节点则返回-1****。**

  **public E set(int index ,E element)** **将当前链表index****位置节点中的对象element****替换为参数element****指定的对象。并返回被替换的对象。**

  **public int size()** **返回链表的长度，即节点的个数。**

  **public boolean contains(Object element)** **判断链表节点中是否有节点含有对象element****。**

 

**四、** **HashMap**

**HashMap<K,V>****也是一个很实用的类， HashMap<K,V>****对象采用散列表这种数据结构存储数据，习惯上称HashMap<K,V>****对象为散列映射对象。散列映射用于存储键/****值数据对，允许把任何数量的键/****值数据对存储在一起。键不可以发生逻辑冲突，即不要两个数据项使用相同的键，如果出现两个数据项对应相同的键，那么，先前散列映射中的键/****值对将被替换。散列映射在它需要更多的存储空间时会自动增大容量。 Hash****函数**

**(1)HashMap<K,V>****泛型类创建的对象称作散列映射，例如:**

  **HashMap<String,Student> hashtable= new HashMap<String,Student>();**

**那么，hashtable****就可以存储“键/****值”对数据，其中的键必须是一个String****对象，键对应的值必须是Student****对象。hashtable****可以调用public V put(K key,V value)****将键/****值对数据存放到散列映射中，该方法同时返回键所对应的值。**

 

**(2)****常用方法:**

  **public void clear()** **清空散列映射。**

  **public Object clone()** **返回当前散列映射的一个克隆。**

  **public boolean containsKey(Object key)** **如果散列映射有键/****值对使用了参数指定的键，方法返回true****，否则返回false****。**

  **public boolean containsValue(Object value)** **如果散列映射有键/****值对的值是参数指定的值，方法返回true****，否则返回false****。**  

**public V get(Object key)** **返回散列映射中使用key****做键的键/****值对中的值。**

  **public boolean isEmpty()** **如果散列映射不含任何键/****值对，方法返回true****，否则返回false****。**

  **public V remove(Object key)** **删除散列映射中键为参数指定的键/****值对，并返回键对应的值。**

**public int size()** **返回散列映射的大小，即散列映射中键/****值对的数目。** 

 

**(3)****遍历散列映射**

  **如果想获得散列映射中所有键/****值对中的值，首先使用**

  **public Collection<V> values()**

  **方法返回一个实现Collection<V>****接口类创建的对象的引用，并要求将该对象的引用返回到Collection<V>****接口变量中。values()****方法返回的对象中存储了散列映射中所有“键/****值”对中的“值”，这样接口变量就可以调用类实现的方法，比如获取Iterator****对象，然后输出所有的值。**

 

 

**练习题：**

一、编写一个泛型类Poker<C,P>，实现两个元素对象的类信息组合。编写1个随机生成花色的Color类，1个随机生成点数的Point类，在主类中调用泛型类随机生成5张扑克牌并打印显示。

 

提示：在Color类和Point类中重写Object类的toString（）方法，该方法分别返回一个随机花色和随机点数。泛型类Poker<C,P>作用就是将C、P两个的toString（）组合起来即可。

 

 

运行效果如下：

 

![img](7-8.%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.assets/clip_image001.jpg)

 

二、ArrayList的使用。编写1个Student类，有1个name成员变量。键盘输入4个人名，并初始化4个学生实例。在主类中定义一个ArrayList<Student>泛型,对ArrayList进行多种操作,包括添加、移除、判断元素是否存在列表中和查找序号、输出列表长度以及遍历输出等。

 

 

提示：必须在Student类中重写equals方法，以此保证只要名字相等，则认为是同一个人.

 

运行效果如下：

![img](7-8.%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.assets/clip_image002.jpg)

 

 

 

 

三、随机布雷。编写1个Block类，有2个成员变量name和boo，以及若干个方法。定义1个LinkList<Block>泛型和1个8*8的Block方阵，将方阵的坐标存储到LinkList泛型中，并将改写随机生成的地雷坐标的名字。在主类中调用泛型并打印出随机布雷方阵。

 

运行效果如下：

![img](7-8.%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.assets/clip_image003.jpg)

 

 

四、HashMap的使用。编写1个Book类，有2个成员变量ISBN和name。键盘输入4本书的书号和书名，并初始化4个Book实例。在主类中定义一个HashMap<K,V>泛型,对HashMap进行多种操作,包括添加、判断元素是否存在表中、输出表长度以及遍历输出等。

 

运行效果如下：

 

![img](7-8.%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.assets/clip_image004.jpg)

 

 

 